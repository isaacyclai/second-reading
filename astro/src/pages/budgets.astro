---
import Layout from "../layouts/Layout.astro";
import fs from "node:fs";
import path from "node:path";
import { hierarchy, treemap, treemapSquarify } from "d3-hierarchy";

// ─── Read & parse CSV ───
const csvPath = path.join(
  process.cwd(),
  "..",
  "data",
  "GovernmentTotalExpenditure.csv",
);
const csvText = fs.readFileSync(csvPath, "utf-8");

function parseCSV(text: string) {
  const lines = text.trim().split("\n");
  return lines
    .slice(1)
    .map((line) => {
      const values: string[] = [];
      let current = "";
      let inQuotes = false;
      for (const char of line) {
        if (char === '"') {
          inQuotes = !inQuotes;
          continue;
        }
        if (char === "," && !inQuotes) {
          values.push(current.trim());
          current = "";
          continue;
        }
        current += char;
      }
      values.push(current.trim());
      return {
        year: parseInt(values[0]),
        estimateType: values[1],
        sector: values[2],
        ministry: values[3],
        expType: values[4],
        amount: parseFloat(values[5]) || 0,
      };
    })
    .filter((r) => !isNaN(r.year));
}

const rows = parseCSV(csvText);

// Use one data version per year so revised values replace estimated ones.
const estimateTypePriority: Record<string, number> = {
  Estimated: 1,
  Revised: 2,
  Actual: 3,
};

const preferredEstimateTypeByYear = new Map<number, string>();
for (const row of rows) {
  const existing = preferredEstimateTypeByYear.get(row.year);
  if (!existing) {
    preferredEstimateTypeByYear.set(row.year, row.estimateType);
    continue;
  }
  const existingPriority = estimateTypePriority[existing] || 0;
  const rowPriority = estimateTypePriority[row.estimateType] || 0;
  if (rowPriority > existingPriority) {
    preferredEstimateTypeByYear.set(row.year, row.estimateType);
  }
}

const filteredRows = rows.filter(
  (row) => preferredEstimateTypeByYear.get(row.year) === row.estimateType,
);

// ─── Aggregate by year → sector → ministry ───
const yearMap = new Map<
  number,
  Map<
    string,
    {
      sector: string;
      ministry: string;
      operating: number;
      development: number;
      estimateType: string;
    }
  >
>();

for (const row of filteredRows) {
  if (!yearMap.has(row.year)) yearMap.set(row.year, new Map());
  const entries = yearMap.get(row.year)!;
  const key = `${row.sector}|||${row.ministry}`;
  if (!entries.has(key)) {
    entries.set(key, {
      sector: row.sector,
      ministry: row.ministry,
      operating: 0,
      development: 0,
      estimateType: row.estimateType,
    });
  }
  const entry = entries.get(key)!;
  if (row.expType === "Operating") entry.operating += row.amount;
  else if (row.expType === "Development") entry.development += row.amount;
}

// ─── Compute treemap layout for each year ───
const W = 1000;
const H = 600;

const sectorOrder = [
  "Social Development",
  "Security and External Relations",
  "Economic Development",
  "Government Administration",
];

interface MinistryCell {
  name: string;
  value: number;
  operating: number;
  development: number;
  x0: number;
  y0: number;
  x1: number;
  y1: number;
}

interface SectorCell {
  name: string;
  value: number;
  x0: number;
  y0: number;
  x1: number;
  y1: number;
  ministries: MinistryCell[];
}

interface YearData {
  total: number;
  estimateType: string;
  sectors: SectorCell[];
}

const allTreemapData: Record<string, YearData> = {};

for (const [year, entries] of yearMap) {
  const entryList = [...entries.values()];

  // Group by sector
  const sectorGroups: Record<
    string,
    { name: string; value: number; operating: number; development: number }[]
  > = {};
  for (const e of entryList) {
    const total = e.operating + e.development;
    if (total <= 0) continue;
    if (!sectorGroups[e.sector]) sectorGroups[e.sector] = [];
    sectorGroups[e.sector].push({
      name: e.ministry,
      value: total,
      operating: e.operating,
      development: e.development,
    });
  }

  const children = sectorOrder
    .filter((s) => sectorGroups[s]?.length > 0)
    .map((s) => ({
      name: s,
      children: sectorGroups[s],
    }));

  if (children.length === 0) continue;

  const root = hierarchy({ name: "Budget", children })
    .sum((d: any) => d.value)
    .sort((a, b) => (b.value || 0) - (a.value || 0));

  treemap()
    .size([W, H])
    .tile(treemapSquarify)
    .paddingTop((d: any) => (d.depth === 0 ? 0 : 18))
    .paddingRight((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingBottom((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingLeft((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingInner(2)(root as any);

  const totalBudget = root.value || 0;

  const sectors: SectorCell[] = (root.children || []).map((s: any) => ({
    name: s.data.name,
    value: s.value,
    x0: s.x0,
    y0: s.y0,
    x1: s.x1,
    y1: s.y1,
    ministries: (s.children || []).map((m: any) => ({
      name: m.data.name,
      value: m.value,
      operating: m.data.operating,
      development: m.data.development,
      x0: m.x0,
      y0: m.y0,
      x1: m.x1,
      y1: m.y1,
    })),
  }));

  allTreemapData[year] = {
    total: totalBudget,
    estimateType: entryList[0]?.estimateType || "Actual",
    sectors,
  };
}

const years = Object.keys(allTreemapData)
  .map(Number)
  .sort((a, b) => a - b);
const defaultYear = years[years.length - 1];

interface SectorTrendPoint {
  year: number;
  total: number;
  operating: number;
  development: number;
}

const sectorTrendSeries = sectorOrder
  .map((sector) => {
    const points: SectorTrendPoint[] = years
      .map((year) => {
        const entries = yearMap.get(year);
        let operating = 0;
        let development = 0;
        if (entries) {
          for (const entry of entries.values()) {
            if (entry.sector !== sector) continue;
            operating += entry.operating;
            development += entry.development;
          }
        }
        return {
          year,
          total: operating + development,
          operating,
          development,
        };
      })
      .filter((p) => p.total > 0);

    return { name: sector, points };
  })
  .filter((series) => series.points.length > 0);
---

<Layout
  title="Budgets"
  description="Singapore Government Budget Expenditure Treemap"
>
  <header class="mb-6">
    <span class="section-label">Government Expenditure</span>
    <h1 class="page-title">Budget</h1>
    <p class="body-prose max-w-prose">
      How Singapore allocates its expenditure across sectors and ministries.
    </p>
  </header>

  <!-- Summary -->
  <div class="flex items-baseline gap-3 mb-4">
    <span
      class="font-masthead text-3xl text-ink tracking-tight leading-none"
      id="total-amount"></span>
    <span
      class="font-sans text-label-sm uppercase tracking-wider text-ink-muted"
      id="estimate-type"></span>
  </div>

  <!-- Year selector -->
  <div class="mb-5 border-b border-t border-border py-3">
    <div
      id="year-buttons"
      class="grid gap-1 grid-cols-[repeat(10,1fr)] sm:grid-cols-[repeat(15,1fr)]"
    >
      {
        years.map((y) => (
          <button
            data-year={y}
            class:list={[
              "year-btn font-sans text-xs py-1 transition-colors cursor-pointer border text-center",
              y === defaultYear
                ? "bg-ink text-page-bg border-ink"
                : "bg-transparent text-ink-muted border-transparent hover:text-ink hover:border-border",
            ]}
          >
            {String(y).slice(-2)}
          </button>
        ))
      }
    </div>
  </div>

  <!-- Legend -->
  <div class="flex flex-wrap gap-x-5 gap-y-1.5 mb-4">
    <div class="flex items-center gap-1.5">
      <span class="w-3 h-3 inline-block" style="background: #e6ead8;"></span>
      <span class="font-sans text-xs text-ink-muted">Social Development</span>
    </div>
    <div class="flex items-center gap-1.5">
      <span class="w-3 h-3 inline-block" style="background: #dce0e8;"></span>
      <span class="font-sans text-xs text-ink-muted"
        >Security & External Relations</span
      >
    </div>
    <div class="flex items-center gap-1.5">
      <span class="w-3 h-3 inline-block" style="background: #ece2ce;"></span>
      <span class="font-sans text-xs text-ink-muted">Economic Development</span>
    </div>
    <div class="flex items-center gap-1.5">
      <span class="w-3 h-3 inline-block" style="background: #e0dcd6;"></span>
      <span class="font-sans text-xs text-ink-muted"
        >Government Administration</span
      >
    </div>
  </div>

  <!-- Treemap -->
  <div id="treemap-container" class="relative border border-border"></div>

  <!-- Sector line chart -->
  <section class="mt-8">
    <div class="mb-3">
      <h2 class="font-masthead text-2xl text-ink tracking-tight leading-none">
        Sector Trends
      </h2>
      <p class="font-sans text-sm text-ink-muted mt-1">
        Total expenditure by sector over time.
      </p>
    </div>
    <div id="sector-line-chart" class="relative border border-border"></div>
    <div id="sector-line-legend" class="mt-3 flex flex-wrap gap-x-5 gap-y-2">
    </div>
  </section>

  <!-- Source note -->
  <p class="font-sans text-xs text-ink-muted mt-4">
    Source: Singapore Government Total Expenditure, data.gov.sg. Amounts in S$
    millions.
  </p>

  <!-- Tooltip -->
  <div
    id="treemap-tooltip"
    class="fixed pointer-events-none opacity-0 z-50 max-w-xs"
    style="transition: opacity 0.12s ease;"
  >
  </div>

  <!-- Line chart tooltip -->
  <div
    id="line-tooltip"
    class="fixed pointer-events-none opacity-0 z-50 max-w-xs"
    style="transition: opacity 0.1s ease;"
  >
  </div>

  <!-- Embed data for client -->
  <div
    id="treemap-data"
    class="hidden"
    data-json={JSON.stringify({
      data: allTreemapData,
      trendSeries: sectorTrendSeries,
      W,
      H,
      defaultYear,
      years,
    })}
  >
  </div>
</Layout>

<style is:global>
  /* ─── Treemap cells ─── */
  #treemap-container {
    padding-bottom: 80%;
  }

  @media (max-width: 640px) {
    #treemap-container {
      padding-bottom: 140%;
    }
  }

  .tm-sector {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid;
    overflow: hidden;
  }

  .tm-sector-label {
    padding: 4px 7px;
    font-family: "Playfair Display", Georgia, serif;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 0.04em;
    color: var(--ink);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1;
  }

  .tm-sector-label span {
    font-family: "Source Serif 4", Georgia, serif;
    font-weight: 300;
    font-size: 9px;
    color: var(--ink-soft);
    margin-left: 4px;
  }

  .tm-cell {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid;
    overflow: hidden;
    padding: 4px 6px;
    cursor: pointer;
    transition: filter 0.15s ease;
  }

  .tm-cell:hover {
    filter: brightness(0.88);
    z-index: 5;
  }

  .tm-cell-name {
    display: block;
    font-family: "Source Serif 4", Georgia, serif;
    font-size: 10px;
    font-weight: 400;
    line-height: 1.25;
    color: var(--ink);
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tm-cell-amount {
    display: block;
    font-family: "Playfair Display", Georgia, serif;
    font-size: 13px;
    font-weight: 400;
    color: var(--ink);
    line-height: 1;
    margin-top: 2px;
  }

  .tm-cell-pct {
    display: block;
    font-family: "DM Sans", system-ui, sans-serif;
    font-size: 8px;
    font-weight: 400;
    color: var(--ink-muted);
    margin-top: 1px;
  }

  /* Tooltip */
  #treemap-tooltip {
    background: var(--ink);
    color: var(--page-bg);
    padding: 12px 16px;
    font-family: "Source Serif 4", Georgia, serif;
    font-size: 13px;
    line-height: 1.4;
    border: 1px solid rgba(255, 255, 255, 0.08);
  }

  #treemap-tooltip .tt-name {
    font-family: "Playfair Display", Georgia, serif;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 4px;
  }

  #treemap-tooltip .tt-amount {
    font-family: "Playfair Display", Georgia, serif;
    font-size: 22px;
    font-weight: 400;
    color: #c9d4b8;
    margin-bottom: 6px;
    line-height: 1;
  }

  #treemap-tooltip .tt-pct {
    font-size: 11px;
    color: #a09888;
    margin-bottom: 1px;
  }

  #treemap-tooltip .tt-breakdown {
    font-size: 10px;
    color: #a09888;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    padding-top: 6px;
    margin-top: 6px;
    line-height: 1.6;
  }

  /* Year button selected state (for JS toggling) */
  .year-btn-active {
    background: var(--ink) !important;
    color: var(--page-bg) !important;
    border-color: var(--ink) !important;
  }

  /* ─── Sector line chart ─── */
  #sector-line-chart {
    min-height: 320px;
    background: var(--page-bg);
    padding-top: 8px;
    padding-bottom: 10px;
  }

  @media (max-width: 640px) {
    #sector-line-chart {
      width: 100vw;
      margin-left: calc(50% - 50vw);
      margin-right: calc(50% - 50vw);
      border-left: 0;
      border-right: 0;
    }
  }

  .sector-line-grid {
    stroke: var(--border);
    stroke-width: 1;
  }

  .sector-line-axis {
    fill: var(--ink-muted);
    font-family: "DM Sans", system-ui, sans-serif;
    font-size: 11px;
  }

  .line-series .line-path {
    fill: none;
    stroke-width: 2.5;
    transition:
      opacity 0.12s ease,
      stroke-width 0.12s ease;
  }

  .line-series .line-endpoint {
    transition:
      opacity 0.12s ease,
      stroke-width 0.12s ease;
  }

  .line-series .line-end-label {
    font-family: "DM Sans", system-ui, sans-serif;
    font-size: 11px;
    transition: opacity 0.12s ease;
    pointer-events: none;
  }

  .line-series.is-dim .line-path,
  .line-series.is-dim .line-endpoint,
  .line-series.is-dim .line-end-label {
    opacity: 0.2;
  }

  .line-series.is-active .line-path {
    stroke-width: 3.5;
  }

  .line-series.is-active .line-endpoint {
    stroke: var(--ink);
    stroke-width: 1.2;
  }

  @media (max-width: 1024px) {
    .line-end-label {
      display: none;
    }
  }

  .sector-line-legend-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border: 1px solid transparent;
    padding: 2px 0;
    color: var(--ink-muted);
    font-family: "DM Sans", system-ui, sans-serif;
    font-size: 12px;
    cursor: pointer;
  }

  .sector-line-legend-item.is-active {
    color: var(--ink);
  }

  .sector-line-legend-item.is-dim {
    opacity: 0.35;
  }

  .sector-line-legend-swatch {
    width: 14px;
    height: 2px;
    display: inline-block;
  }

  #line-tooltip {
    background: var(--ink);
    color: var(--page-bg);
    padding: 10px 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    font-family: "Source Serif 4", Georgia, serif;
    font-size: 12px;
    line-height: 1.35;
  }

  #line-tooltip .tt-name {
    font-family: "Playfair Display", Georgia, serif;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 4px;
  }

  #line-tooltip .tt-year {
    color: #a09888;
    margin-bottom: 2px;
  }

  #line-tooltip .tt-amount {
    font-family: "Playfair Display", Georgia, serif;
    font-size: 20px;
    line-height: 1;
  }
</style>

<script>
  const raw = document.getElementById("treemap-data");
  if (!raw) throw new Error("Missing treemap data");
  const { data, trendSeries, W, H, defaultYear, years } = JSON.parse(
    raw.dataset.json || "{}",
  );

  const container = document.getElementById("treemap-container")!;
  const tooltip = document.getElementById("treemap-tooltip")!;
  const lineContainer = document.getElementById("sector-line-chart");
  const lineLegend = document.getElementById("sector-line-legend");
  const lineTooltip = document.getElementById("line-tooltip");
  const totalEl = document.getElementById("total-amount")!;
  const typeEl = document.getElementById("estimate-type")!;

  const SECTOR_STYLES: Record<string, { bg: string; border: string }> = {
    "Social Development": { bg: "#e6ead8", border: "#c8ceb4" },
    "Security and External Relations": { bg: "#dce0e8", border: "#bcc2cc" },
    "Economic Development": { bg: "#ece2ce", border: "#d0c4a8" },
    "Government Administration": { bg: "#e0dcd6", border: "#c4c0b8" },
  };
  const SECTOR_LINE_COLORS: Record<string, string> = {
    "Social Development": "#6c7b4f",
    "Security and External Relations": "#6f829f",
    "Economic Development": "#a08a58",
    "Government Administration": "#8d7c68",
  };

  function fmt(millions: number): string {
    if (millions >= 1000) return "$" + (millions / 1000).toFixed(1) + "B";
    if (millions >= 1) return "$" + Math.round(millions) + "M";
    return "<$1M";
  }

  function pctX(v: number): string {
    return (v / W) * 100 + "%";
  }
  function pctY(v: number): string {
    return (v / H) * 100 + "%";
  }

  function renderTreemap(year: number) {
    const yd = data[year];
    if (!yd) return;

    container.innerHTML = "";
    totalEl.textContent = fmt(yd.total);
    typeEl.textContent = yd.estimateType + " " + year;

    // Update year buttons
    document.querySelectorAll<HTMLButtonElement>(".year-btn").forEach((btn) => {
      const y = parseInt(btn.dataset.year || "0");
      btn.classList.toggle("year-btn-active", y === year);
      if (y === year) {
        btn.classList.remove(
          "bg-transparent",
          "text-ink-muted",
          "border-transparent",
        );
      } else {
        btn.classList.remove("bg-ink", "text-page-bg", "border-ink");
        btn.classList.add(
          "bg-transparent",
          "text-ink-muted",
          "border-transparent",
        );
      }
    });

    for (const sector of yd.sectors) {
      const style = SECTOR_STYLES[sector.name] || {
        bg: "#e0dcd6",
        border: "#c4c0b8",
      };

      // Sector background
      const sDiv = document.createElement("div");
      sDiv.className = "tm-sector";
      sDiv.style.left = pctX(sector.x0);
      sDiv.style.top = pctY(sector.y0);
      sDiv.style.width = pctX(sector.x1 - sector.x0);
      sDiv.style.height = pctY(sector.y1 - sector.y0);
      sDiv.style.background = style.bg;
      sDiv.style.borderColor = style.border;

      // Sector label
      const label = document.createElement("div");
      label.className = "tm-sector-label";
      label.innerHTML = sector.name + " <span>" + fmt(sector.value) + "</span>";
      sDiv.appendChild(label);
      container.appendChild(sDiv);

      // Ministry cells
      for (const m of sector.ministries) {
        const cW = m.x1 - m.x0;
        const cH = m.y1 - m.y0;

        const cell = document.createElement("div");
        cell.className = "tm-cell";
        cell.style.left = pctX(m.x0);
        cell.style.top = pctY(m.y0);
        cell.style.width = pctX(cW);
        cell.style.height = pctY(cH);
        cell.style.background = style.bg;
        cell.style.borderColor = style.border;

        // Name
        const name = document.createElement("span");
        name.className = "tm-cell-name";
        name.textContent = m.name;
        cell.appendChild(name);

        // Amount (if cell large enough)
        if (cW > 70 && cH > 45) {
          const amt = document.createElement("span");
          amt.className = "tm-cell-amount";
          amt.textContent = fmt(m.value);
          cell.appendChild(amt);
        }

        // Percentage (if cell has room)
        if (cW > 90 && cH > 65) {
          const pct = document.createElement("span");
          pct.className = "tm-cell-pct";
          pct.textContent =
            ((m.value / yd.total) * 100).toFixed(1) + "% of total";
          cell.appendChild(pct);
        }

        // Tooltip events
        cell.addEventListener("mouseenter", (e) => {
          const pctTotal = ((m.value / yd.total) * 100).toFixed(1);
          const pctSector = ((m.value / sector.value) * 100).toFixed(1);
          tooltip.innerHTML =
            `<div class="tt-name">${m.name}</div>` +
            `<div class="tt-amount">${fmt(m.value)}</div>` +
            `<div class="tt-pct">${pctTotal}% of Total Budget</div>` +
            `<div class="tt-pct">${pctSector}% of ${sector.name}</div>` +
            `<div class="tt-breakdown">Operating: ${fmt(m.operating)}<br/>Development: ${fmt(m.development)}</div>`;
          tooltip.style.opacity = "1";
          positionTooltip(e);
        });

        cell.addEventListener("mousemove", positionTooltip);

        cell.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
        });

        container.appendChild(cell);
      }
    }
  }

  function fmtCompactMillions(millions: number): string {
    if (millions >= 1000) return "$" + (millions / 1000).toFixed(1) + "B";
    return "$" + Math.round(millions) + "M";
  }

  function niceCeil(value: number): number {
    if (value <= 0) return 1;
    const power = 10 ** Math.floor(Math.log10(value));
    const n = value / power;
    const step = n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10;
    return step * power;
  }

  function renderSectorLineChart() {
    if (!lineContainer || !lineLegend || !lineTooltip) return;
    if (!Array.isArray(trendSeries) || trendSeries.length === 0) return;

    const width = lineContainer.clientWidth || 900;
    const height = Math.max(320, Math.round(width * 0.5));
    const isMobile = window.matchMedia("(max-width: 640px)").matches;
    const isNarrow = window.matchMedia("(max-width: 1024px)").matches;
    const margin = {
      top: 30,
      right: isNarrow ? 24 : 136,
      bottom: 56,
      left: isMobile ? 62 : 56,
    };
    const plotW = width - margin.left - margin.right;
    const plotH = height - margin.top - margin.bottom;
    if (plotW <= 0 || plotH <= 0) return;

    const series = trendSeries
      .map((s: any) => ({
        name: s.name,
        points: [...(s.points || [])].sort((a, b) => a.year - b.year),
      }))
      .filter((s: any) => s.points.length > 0);
    if (series.length === 0) return;

    const minYear = years[0];
    const maxYear = years[years.length - 1];
    const yearSpan = Math.max(1, maxYear - minYear);
    const maxValue = Math.max(
      ...series.flatMap((s: any) => s.points.map((p: any) => p.total)),
      1,
    );
    const yMax = niceCeil(maxValue * 1.1);

    const xFor = (year: number) =>
      margin.left + ((year - minYear) / yearSpan) * plotW;
    const yFor = (value: number) => margin.top + plotH - (value / yMax) * plotH;

    const ns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("width", String(width));
    svg.setAttribute("height", String(height));
    svg.setAttribute("role", "img");
    svg.setAttribute("aria-label", "Sector expenditure over time");
    svg.style.display = "block";
    svg.style.width = "100%";
    svg.style.height = "auto";

    const yTicks = 5;
    for (let i = 0; i <= yTicks; i++) {
      const v = (yMax * i) / yTicks;
      const y = yFor(v);

      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", String(margin.left));
      line.setAttribute("x2", String(margin.left + plotW));
      line.setAttribute("y1", String(y));
      line.setAttribute("y2", String(y));
      line.setAttribute("class", "sector-line-grid");
      svg.appendChild(line);

      const label = document.createElementNS(ns, "text");
      label.setAttribute("x", String(margin.left - 8));
      label.setAttribute("y", String(y + 4));
      label.setAttribute("text-anchor", "end");
      label.setAttribute("class", "sector-line-axis");
      label.textContent = fmtCompactMillions(v);
      svg.appendChild(label);
    }

    const xLabelStep = Math.max(
      1,
      Math.ceil(years.length / (isMobile ? 5 : 8)),
    );
    const minTickGapPx = isMobile ? 52 : 40;
    const selectedTickYears: number[] = [];
    let lastTickX = -Infinity;

    for (let idx = 0; idx < years.length; idx++) {
      const year = years[idx];
      const isCandidate = idx % xLabelStep === 0 || idx === years.length - 1;
      if (!isCandidate) continue;
      const x = xFor(year);
      if (x - lastTickX < minTickGapPx && idx !== years.length - 1) continue;
      if (idx === years.length - 1 && x - lastTickX < minTickGapPx) {
        selectedTickYears.pop();
      }
      selectedTickYears.push(year);
      lastTickX = x;
    }

    selectedTickYears.forEach((year) => {
      const x = xFor(year);
      const label = document.createElementNS(ns, "text");
      label.setAttribute("x", String(x));
      label.setAttribute("y", String(height - 12));
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("class", "sector-line-axis");
      label.textContent = String(year);
      svg.appendChild(label);
    });

    function nearestPoint(points: any[], yearHint: number) {
      let best = points[0];
      let bestDist = Math.abs(best.year - yearHint);
      for (const point of points) {
        const dist = Math.abs(point.year - yearHint);
        if (dist < bestDist) {
          best = point;
          bestDist = dist;
        }
      }
      return best;
    }

    function positionLineTooltip(e: MouseEvent) {
      if (!lineTooltip) return;
      const pad = 12;
      const edgePad = 8;
      const rect = lineTooltip.getBoundingClientRect();
      let x = e.clientX + pad;
      let y = e.clientY + pad;

      if (x + rect.width + edgePad > window.innerWidth)
        x = e.clientX - rect.width - pad;
      if (y + rect.height + edgePad > window.innerHeight)
        y = e.clientY - rect.height - pad;

      x = Math.max(
        edgePad,
        Math.min(x, window.innerWidth - rect.width - edgePad),
      );
      y = Math.max(
        edgePad,
        Math.min(y, window.innerHeight - rect.height - edgePad),
      );

      lineTooltip.style.left = x + "px";
      lineTooltip.style.top = y + "px";
    }

    function setActiveSector(sectorName: string | null) {
      svg.querySelectorAll<SVGGElement>(".line-series").forEach((group) => {
        const isActive =
          sectorName !== null && group.dataset.sector === sectorName;
        const isDim =
          sectorName !== null && group.dataset.sector !== sectorName;
        group.classList.toggle("is-active", isActive);
        group.classList.toggle("is-dim", isDim);
        const endpoint =
          group.querySelector<SVGCircleElement>(".line-endpoint");
        if (endpoint) endpoint.setAttribute("r", isActive ? "5" : "4");
      });

      lineLegend
        .querySelectorAll<HTMLElement>(".sector-line-legend-item")
        .forEach((item) => {
          const isActive =
            sectorName !== null && item.dataset.sector === sectorName;
          const isDim =
            sectorName !== null && item.dataset.sector !== sectorName;
          item.classList.toggle("is-active", isActive);
          item.classList.toggle("is-dim", isDim);
        });
    }

    lineLegend.innerHTML = "";

    for (const s of series) {
      const color =
        SECTOR_LINE_COLORS[s.name] || SECTOR_STYLES[s.name]?.border || "#777";
      const points = s.points;
      const d = points
        .map(
          (p: any, i: number) =>
            `${i === 0 ? "M" : "L"}${xFor(p.year)},${yFor(p.total)}`,
        )
        .join(" ");

      const group = document.createElementNS(ns, "g");
      group.setAttribute("class", "line-series");
      group.dataset.sector = s.name;

      const hitPath = document.createElementNS(ns, "path");
      hitPath.setAttribute("d", d);
      hitPath.setAttribute("fill", "none");
      hitPath.setAttribute("stroke", "transparent");
      hitPath.setAttribute("stroke-width", isMobile ? "36" : "28");
      hitPath.style.pointerEvents = "stroke";

      const path = document.createElementNS(ns, "path");
      path.setAttribute("d", d);
      path.setAttribute("class", "line-path");
      path.setAttribute("stroke", color);

      const last = points[points.length - 1];
      const endX = xFor(last.year);
      const endY = yFor(last.total);

      const endpoint = document.createElementNS(ns, "circle");
      endpoint.setAttribute("cx", String(endX));
      endpoint.setAttribute("cy", String(endY));
      endpoint.setAttribute("r", "4");
      endpoint.setAttribute("fill", color);
      endpoint.setAttribute("class", "line-endpoint");
      endpoint.setAttribute("stroke", "none");

      const endLabel = document.createElementNS(ns, "text");
      endLabel.setAttribute("x", String(width - margin.right + 10));
      endLabel.setAttribute("y", String(endY + 4));
      endLabel.setAttribute("class", "line-end-label");
      endLabel.setAttribute("fill", color);
      endLabel.textContent = `${s.name} ${fmtCompactMillions(last.total)}`;

      function showLineTooltip(e: MouseEvent) {
        const rect = svg.getBoundingClientRect();
        const localX = e.clientX - rect.left;
        const approxYear =
          minYear +
          Math.max(0, Math.min(1, (localX - margin.left) / plotW)) * yearSpan;
        const point = nearestPoint(points, approxYear);
        lineTooltip.innerHTML =
          `<div class="tt-name">${s.name}</div>` +
          `<div class="tt-year">${point.year}</div>` +
          `<div class="tt-amount">${fmtCompactMillions(point.total)}</div>`;
        lineTooltip.style.opacity = "1";
        positionLineTooltip(e);
      }

      hitPath.addEventListener("mouseenter", () => setActiveSector(s.name));
      hitPath.addEventListener("mousemove", (e) => {
        setActiveSector(s.name);
        showLineTooltip(e);
      });
      hitPath.addEventListener("mouseleave", () => {
        lineTooltip.style.opacity = "0";
      });

      group.appendChild(hitPath);
      group.appendChild(path);
      group.appendChild(endpoint);
      group.appendChild(endLabel);
      svg.appendChild(group);

      const legendItem = document.createElement("div");
      legendItem.className = "sector-line-legend-item";
      legendItem.dataset.sector = s.name;
      legendItem.innerHTML = `<span class="sector-line-legend-swatch" style="background:${color};"></span><span>${s.name}</span>`;
      legendItem.addEventListener("mouseenter", () => setActiveSector(s.name));
      legendItem.addEventListener("mouseleave", () => setActiveSector(null));
      lineLegend.appendChild(legendItem);
    }

    lineContainer.innerHTML = "";
    lineContainer.appendChild(svg);

    lineContainer.onmouseleave = () => {
      setActiveSector(null);
      lineTooltip.style.opacity = "0";
    };
  }

  function positionTooltip(e: MouseEvent) {
    const pad = 14;
    const edgePad = 8;
    const rect = tooltip.getBoundingClientRect();
    const tw = rect.width;
    const th = rect.height;

    // Prefer placing on the cursor's lower-right, then flip, then clamp.
    let x = e.clientX + pad;
    let y = e.clientY + pad;

    if (x + tw + edgePad > window.innerWidth) {
      x = e.clientX - tw - pad;
    }
    if (y + th + edgePad > window.innerHeight) {
      y = e.clientY - th - pad;
    }

    x = Math.max(edgePad, Math.min(x, window.innerWidth - tw - edgePad));
    y = Math.max(edgePad, Math.min(y, window.innerHeight - th - edgePad));

    tooltip.style.left = x + "px";
    tooltip.style.top = y + "px";
  }

  // Year button click handlers
  document.querySelectorAll<HTMLButtonElement>(".year-btn").forEach((btn) => {
    btn.addEventListener("click", () => {
      const y = parseInt(btn.dataset.year || "0");
      if (y) renderTreemap(y);
    });
  });

  // Keyboard navigation for year buttons
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
      const activeBtn = document.querySelector(".year-btn-active");
      if (!activeBtn) return;
      const currentYear = parseInt(
        (activeBtn as HTMLElement).dataset.year || "0",
      );
      const idx = years.indexOf(currentYear);
      if (idx === -1) return;
      const next =
        e.key === "ArrowRight"
          ? years[Math.min(idx + 1, years.length - 1)]
          : years[Math.max(idx - 1, 0)];
      if (next !== currentYear) renderTreemap(next);
    }
  });

  // Initial render
  renderTreemap(defaultYear);
  renderSectorLineChart();

  let resizeTimer: number | undefined;
  window.addEventListener("resize", () => {
    window.clearTimeout(resizeTimer);
    resizeTimer = window.setTimeout(() => {
      renderSectorLineChart();
    }, 140);
  });
</script>
