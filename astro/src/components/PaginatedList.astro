---
interface Props {
  containerId: string;
  itemSelector: string;
  contentType: "question" | "bill" | "motion" | "session";
  dataUrl: string;
  totalCount: number;
  pageSize?: number;
  placeholder?: string;
}

const {
  containerId,
  itemSelector,
  contentType,
  dataUrl,
  totalCount,
  pageSize = 20,
  placeholder = "Search...",
} = Astro.props;
---

<div
  class="paginated-list-wrapper"
  data-container={containerId}
  data-selector={itemSelector}
  data-type={contentType}
  data-url={dataUrl}
  data-total={totalCount}
  data-page-size={pageSize}
>
  <!-- Search input -->
  <div class="mb-6">
    <div class="relative">
      <svg
        class="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-ink/40 pointer-events-none"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="1.5"
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg>
      <input
        type="text"
        class="paginated-search-input w-full rounded-lg border border-border bg-surface px-4 py-2.5 pl-10 pr-10 font-ui text-sm text-ink placeholder:text-ink/40 focus:border-accent focus:outline-none focus:ring-1 focus:ring-accent/20 transition-colors"
        placeholder={placeholder}
        autocomplete="off"
        spellcheck="false"
      />
      <button
        type="button"
        class="paginated-clear-btn absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 text-ink/40 hover:text-ink transition-colors hidden"
        aria-label="Clear search"
      >
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- Status text -->
  <p class="paginated-status font-sans text-sm text-ink-muted mb-6">
    Showing 1-{Math.min(pageSize, totalCount)} of {totalCount}
  </p>

  <!-- Content slot (static HTML items for page 1) -->
  <slot />

  <!-- Pagination controls -->
  <nav
    class="paginated-controls flex items-center justify-center gap-4 py-6"
    aria-label="Pagination"
  >
    <button
      class="paginated-prev flex items-center gap-1.5 rounded-lg border border-border bg-surface px-4 py-2 font-ui text-sm text-ink/70 transition-all hover:border-accent/30 hover:text-accent disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:border-border disabled:hover:text-ink/70"
      disabled
    >
      <svg
        class="h-4 w-4"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="1.5"
          d="M15 19l-7-7 7-7"></path>
      </svg>
      Previous
    </button>
    <span class="paginated-info font-ui text-sm text-ink/50">
      Page <span class="paginated-current font-medium text-ink">1</span> of <span
        class="paginated-total font-medium text-ink"
        >{Math.ceil(totalCount / pageSize)}</span
      >
    </span>
    <button
      class="paginated-next flex items-center gap-1.5 rounded-lg border border-border bg-surface px-4 py-2 font-ui text-sm text-ink/70 transition-all hover:border-accent/30 hover:text-accent disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:border-border disabled:hover:text-ink/70"
    >
      Next
      <svg
        class="h-4 w-4"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="1.5"
          d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </nav>
</div>

<script>
  interface DataItem {
    id: string;
    title?: string;
    date?: string;
    type?: string;
    category?: string;
    ministry?: string;
    speakers?: string[];
    snippet?: string;
    parliament?: number;
    sessionNo?: number;
    sittingNo?: number;
    sectionCount?: number;
  }

  interface DataResponse {
    items: DataItem[];
    total: number;
  }

  interface PagefindResult {
    id: string;
    data: () => Promise<{
      meta?: { id?: string };
      url: string;
      excerpt: string;
    }>;
  }

  interface PagefindSearch {
    results: PagefindResult[];
  }

  interface Pagefind {
    search: (
      query: string,
      options?: { filters?: Record<string, string> },
    ) => Promise<PagefindSearch>;
  }

  // Type badge colors
  const typeBadgeConfig: Record<string, { label: string; classes: string }> = {
    OA: {
      label: "Oral Answer",
      classes: "bg-amber-50 text-amber-700",
    },
    WA: {
      label: "Written Answer",
      classes: "bg-purple-50 text-purple-700",
    },
    WANA: {
      label: "Written (No Answer)",
      classes: "bg-slate-100 text-slate-600",
    },
  };

  const categoryLabels: Record<string, string> = {
    motion: "Motion",
    adjournment_motion: "Adjournment Motion",
  };

  function formatDate(dateStr: string | undefined | null): string {
    if (!dateStr) return "";
    return new Date(dateStr).toLocaleDateString("en-SG", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  }

  function formatSessionDate(dateStr: string | undefined | null): string {
    if (!dateStr) return "";
    return new Date(dateStr).toLocaleDateString("en-SG", {
      day: "numeric",
      month: "long",
      year: "numeric",
    });
  }

  function getOrdinal(n: number): string {
    const s = ["th", "st", "nd", "rd"];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
  }

  function escapeHtml(text: string): string {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // Card renderers for each content type
  function renderQuestionCard(item: DataItem, itemClass: string): HTMLElement {
    const wrapper = document.createElement("div");
    wrapper.className = itemClass;

    const typeConfig =
      item.category && categoryLabels[item.category]
        ? {
            label: categoryLabels[item.category],
            classes: "bg-indigo-50 text-indigo-700",
          }
        : typeBadgeConfig[item.type || ""] || {
            label: item.type,
            classes: "bg-slate-100 text-slate-600",
          };

    const speakersHtml =
      item.speakers && item.speakers.length > 0
        ? `<div class="flex flex-wrap gap-2 mb-2">
          ${item.speakers
            .slice(0, 3)
            .map(
              (s) =>
                `<span class="font-sans text-xs text-accent">${escapeHtml(s)}</span>`,
            )
            .join("")}
          ${item.speakers.length > 3 ? `<span class="font-sans text-xs text-ink-muted">+${item.speakers.length - 3} more</span>` : ""}
        </div>`
        : "";

    const snippetHtml = item.snippet
      ? `<p class="font-body text-sm text-ink-soft leading-relaxed line-clamp-1">${escapeHtml(item.snippet)}${item.snippet.length >= 150 ? "..." : ""}</p>`
      : "";

    wrapper.innerHTML = `
      <a href="/questions/${item.id}" class="group block p-5 border-b border-border transition-colors hover:bg-warm cursor-pointer" data-pagefind-meta="id:${item.id}">
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <span class="inline-block font-sans text-label-sm uppercase tracking-wider px-2 py-0.5 rounded ${typeConfig.classes}">${escapeHtml(typeConfig.label)}</span>
          ${item.ministry ? `<span class="inline-block font-sans text-label-sm uppercase tracking-wider px-2 py-0.5 rounded bg-status-passed-bg text-status-passed">${escapeHtml(item.ministry)}</span>` : ""}
          ${item.date ? `<span class="font-sans text-xs text-ink-muted">${formatDate(item.date)}</span>` : ""}
        </div>
        <h3 class="font-display text-lg text-ink leading-snug mb-2 group-hover:text-accent transition-colors line-clamp-2">${escapeHtml(item.title || "")}</h3>
        ${speakersHtml}
        ${snippetHtml}
      </a>
    `;
    return wrapper;
  }

  function renderBillCard(item: DataItem, itemClass: string): HTMLElement {
    const wrapper = document.createElement("div");
    wrapper.className = itemClass;

    wrapper.innerHTML = `
      <a href="/bills/${item.id}" class="group block p-5 border-b border-border transition-colors hover:bg-warm cursor-pointer" data-pagefind-meta="id:${item.id}">
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <span class="inline-block font-sans text-label-sm uppercase tracking-wider px-2 py-0.5 rounded bg-ink/5 text-ink/60">1st Reading</span>
          ${item.date ? `<span class="font-sans text-xs text-ink-muted">${formatDate(item.date)}</span>` : ""}
        </div>
        <h3 class="font-display text-lg text-ink leading-snug mb-2 group-hover:text-accent transition-colors">${escapeHtml(item.title || "")}</h3>
        ${item.ministry ? `<div class="font-sans text-sm text-ink-muted">${escapeHtml(item.ministry)}</div>` : ""}
      </a>
    `;
    return wrapper;
  }

  function renderSessionCard(item: DataItem, itemClass: string): HTMLElement {
    const wrapper = document.createElement("div");
    wrapper.className = itemClass;

    wrapper.innerHTML = `
      <a href="/sessions/${item.id}" class="group grid grid-cols-[140px_1fr_auto] items-center gap-6 py-4 border-b border-border transition-colors hover:bg-warm cursor-pointer px-2" data-pagefind-meta="id:${item.id}">
        <div class="font-display text-base text-ink">${formatSessionDate(item.date)}</div>
        <div class="font-sans text-sm text-ink-muted">
          ${getOrdinal(item.parliament || 0)} Parliament · ${getOrdinal(item.sessionNo || 0)} Session · ${getOrdinal(item.sittingNo || 0)} Sitting
        </div>
        <div class="font-sans text-xs text-ink-soft">
          ${item.sectionCount !== undefined ? `${item.sectionCount} items` : ""}
        </div>
      </a>
    `;
    return wrapper;
  }

  function renderCard(
    item: DataItem,
    contentType: string,
    itemClass: string,
  ): HTMLElement {
    switch (contentType) {
      case "question":
      case "motion":
        return renderQuestionCard(item, itemClass);
      case "bill":
        return renderBillCard(item, itemClass);
      case "session":
        return renderSessionCard(item, itemClass);
      default:
        return renderQuestionCard(item, itemClass);
    }
  }

  let pagefind: Pagefind | null = null;

  async function loadPagefind(): Promise<Pagefind | null> {
    if (pagefind) return pagefind;
    try {
      const base = import.meta.env.BASE_URL || "/";
      const pagefindPath = `${base}pagefind/pagefind.js`.replace(/\/+/g, "/");
      pagefind = (await import(/* @vite-ignore */ pagefindPath)) as Pagefind;
      return pagefind;
    } catch (e) {
      console.warn("Pagefind not available - search will be disabled.");
      return null;
    }
  }

  function initPaginatedList() {
    document.querySelectorAll(".paginated-list-wrapper").forEach((wrapper) => {
      const containerId = wrapper.getAttribute("data-container");
      const selector = wrapper.getAttribute("data-selector");
      const contentType = wrapper.getAttribute("data-type") || "question";
      const dataUrl = wrapper.getAttribute("data-url");
      const totalCount = parseInt(
        wrapper.getAttribute("data-total") || "0",
        10,
      );
      const pageSize = parseInt(
        wrapper.getAttribute("data-page-size") || "20",
        10,
      );

      const container = document.getElementById(containerId!);
      if (!container) return;

      const input = wrapper.querySelector(
        ".paginated-search-input",
      ) as HTMLInputElement;
      const clearBtn = wrapper.querySelector(
        ".paginated-clear-btn",
      ) as HTMLButtonElement;
      const statusEl = wrapper.querySelector(
        ".paginated-status",
      ) as HTMLElement;
      const controls = wrapper.querySelector(
        ".paginated-controls",
      ) as HTMLElement;
      const prevBtn = wrapper.querySelector(
        ".paginated-prev",
      ) as HTMLButtonElement;
      const nextBtn = wrapper.querySelector(
        ".paginated-next",
      ) as HTMLButtonElement;
      const currentSpan = wrapper.querySelector(
        ".paginated-current",
      ) as HTMLElement;
      const totalSpan = wrapper.querySelector(
        ".paginated-total",
      ) as HTMLElement;

      if (!input) return;

      // Check if already initialized
      if (input.hasAttribute("data-paginated-initialized")) return;
      input.setAttribute("data-paginated-initialized", "true");

      // Derive item class from selector (e.g., ".question-item" -> "question-item")
      const itemClass = selector!.replace(/^\./, "");

      // State
      let currentPage = 1;
      let isSearchMode = false;
      let searchResults: string[] = []; // IDs of matching items in relevance order
      let jsonData: DataItem[] | null = null;
      let dynamicItems: HTMLElement[] = []; // Track dynamically created items

      // Get all static items (page 1 only)
      const staticItems = Array.from(
        container.querySelectorAll(selector!),
      ) as HTMLElement[];

      // Build ID map for search results
      const staticItemById = new Map<string, HTMLElement>();
      staticItems.forEach((item) => {
        const anchor = item.querySelector(
          "a[data-pagefind-meta]",
        ) as HTMLElement;
        if (anchor) {
          const meta = anchor.getAttribute("data-pagefind-meta");
          const match = meta?.match(/id:([^,]+)/);
          if (match) {
            staticItemById.set(match[1], item);
          }
        }
      });

      // Remove animation classes after initial load
      setTimeout(() => {
        staticItems.forEach((item) => {
          item.classList.remove(
            "animate-fade-up",
            "animate-fade-in",
            "animate-slide-down",
          );
          item.style.animationDelay = "";
        });
      }, 1000);

      // Fetch JSON data for pagination
      async function fetchJsonData(): Promise<DataItem[]> {
        if (jsonData) return jsonData;
        try {
          const response = await fetch(dataUrl!);
          const data: DataResponse = await response.json();
          jsonData = data.items;
          return jsonData;
        } catch (e) {
          console.error("Failed to fetch JSON data:", e);
          return [];
        }
      }

      function clearDynamicItems() {
        dynamicItems.forEach((item) => item.remove());
        dynamicItems = [];
      }

      function updateUrlParams() {
        const url = new URL(window.location.href);
        if (isSearchMode && input.value) {
          url.searchParams.set("q", input.value);
          url.searchParams.delete("page");
        } else if (currentPage > 1) {
          url.searchParams.set("page", String(currentPage));
          url.searchParams.delete("q");
        } else {
          url.searchParams.delete("page");
          url.searchParams.delete("q");
        }
        window.history.replaceState({}, "", url.toString());
      }

      async function updateDisplay() {
        const totalPages = Math.ceil(totalCount / pageSize);

        if (isSearchMode) {
          // Search mode: show matching items from static HTML only
          // (search only works with items that have been indexed by Pagefind)
          clearDynamicItems();

          const totalResults = searchResults.length;
          const searchTotalPages = Math.ceil(totalResults / pageSize);
          const start = (currentPage - 1) * pageSize;
          const end = start + pageSize;
          const pageIds = new Set(searchResults.slice(start, end));

          // Hide all static items first
          staticItems.forEach((item) => {
            item.style.display = "none";
          });

          // Show matching items for current page
          for (const id of searchResults.slice(start, end)) {
            const item = staticItemById.get(id);
            if (item) {
              item.style.display = "";
            }
          }

          // Update status
          if (totalResults === 0) {
            statusEl.textContent = `No results found`;
          } else {
            const rangeStart = totalResults === 0 ? 0 : start + 1;
            const rangeEnd = Math.min(end, totalResults);
            statusEl.textContent = `Found ${totalResults} results (${rangeStart}-${rangeEnd})`;
          }

          // Update pagination
          currentSpan.textContent = String(currentPage);
          totalSpan.textContent = String(searchTotalPages || 1);
          prevBtn.disabled = currentPage === 1;
          nextBtn.disabled =
            currentPage >= searchTotalPages || searchTotalPages === 0;
          controls.style.display = searchTotalPages <= 1 ? "none" : "";
        } else {
          // Browse mode: page 1 uses static items, pages 2+ use JSON
          clearDynamicItems();

          if (currentPage === 1) {
            // Show static items for page 1
            staticItems.forEach((item) => {
              item.style.display = "";
            });
          } else {
            // Hide static items and render from JSON
            staticItems.forEach((item) => {
              item.style.display = "none";
            });

            const data = await fetchJsonData();
            const start = (currentPage - 1) * pageSize;
            const end = start + pageSize;
            const pageItems = data.slice(start, end);

            const fragment = document.createDocumentFragment();
            pageItems.forEach((item) => {
              const card = renderCard(item, contentType, itemClass);
              dynamicItems.push(card);
              fragment.appendChild(card);
            });
            container.appendChild(fragment);
          }

          // Update status
          const start = (currentPage - 1) * pageSize;
          const end = Math.min(currentPage * pageSize, totalCount);
          const rangeStart = totalCount === 0 ? 0 : start + 1;
          statusEl.textContent = `Showing ${rangeStart}-${end} of ${totalCount}`;

          // Update pagination
          currentSpan.textContent = String(currentPage);
          totalSpan.textContent = String(totalPages || 1);
          prevBtn.disabled = currentPage === 1;
          nextBtn.disabled = currentPage >= totalPages;
          controls.style.display = totalPages <= 1 ? "none" : "";
        }

        updateUrlParams();
      }

      let debounceTimer: ReturnType<typeof setTimeout>;

      async function performSearch(query: string) {
        if (!query.trim()) {
          // Exit search mode
          isSearchMode = false;
          searchResults = [];
          currentPage = 1;
          clearBtn.classList.add("hidden");
          await updateDisplay();
          return;
        }

        clearBtn.classList.remove("hidden");
        const pf = await loadPagefind();

        if (!pf) {
          // Fallback: simple text matching on static items
          isSearchMode = true;
          const lowerQuery = query.toLowerCase();
          searchResults = [];

          staticItems.forEach((item) => {
            const text = item.textContent?.toLowerCase() || "";
            if (text.includes(lowerQuery)) {
              const anchor = item.querySelector(
                "a[data-pagefind-meta]",
              ) as HTMLElement;
              if (anchor) {
                const meta = anchor.getAttribute("data-pagefind-meta");
                const match = meta?.match(/id:([^,]+)/);
                if (match) {
                  searchResults.push(match[1]);
                }
              }
            }
          });

          currentPage = 1;
          await updateDisplay();
          return;
        }

        // Use Pagefind for search
        isSearchMode = true;
        const results = await pf.search(query, {
          filters: { type: contentType },
        });

        // Get matching IDs in relevance order
        searchResults = [];
        for (const result of results.results) {
          const data = await result.data();
          if (data.meta?.id) {
            searchResults.push(data.meta.id);
          }
        }

        currentPage = 1;
        await updateDisplay();
      }

      // Event listeners
      input.addEventListener("input", () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          performSearch(input.value);
        }, 150);
      });

      clearBtn.addEventListener("click", () => {
        input.value = "";
        performSearch("");
        input.focus();
      });

      input.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && input.value) {
          input.value = "";
          performSearch("");
        }
      });

      prevBtn.addEventListener("click", async () => {
        if (currentPage > 1) {
          currentPage--;
          await updateDisplay();
        }
      });

      nextBtn.addEventListener("click", async () => {
        const totalItems = isSearchMode ? searchResults.length : totalCount;
        const totalPages = Math.ceil(totalItems / pageSize);
        if (currentPage < totalPages) {
          currentPage++;
          await updateDisplay();
        }
      });

      // Preload pagefind on focus
      input.addEventListener("focus", () => loadPagefind(), { once: true });

      // Handle back/forward navigation
      window.addEventListener("popstate", async () => {
        const urlParams = new URLSearchParams(window.location.search);
        const pageParam = urlParams.get("page");
        const queryParam = urlParams.get("q");

        if (queryParam) {
          input.value = queryParam;
          await performSearch(queryParam);
        } else {
          input.value = "";
          isSearchMode = false;
          searchResults = [];
          currentPage = pageParam ? parseInt(pageParam, 10) : 1;
          if (!Number.isFinite(currentPage) || currentPage < 1) currentPage = 1;
          await updateDisplay();
        }
      });

      // Initialize from URL params
      const urlParams = new URLSearchParams(window.location.search);
      const initialQuery = urlParams.get("q");
      const initialPage = urlParams.get("page");

      if (initialQuery) {
        input.value = initialQuery;
        performSearch(initialQuery);
      } else if (initialPage) {
        currentPage = parseInt(initialPage, 10);
        if (!Number.isFinite(currentPage) || currentPage < 1) currentPage = 1;
        updateDisplay();
      } else {
        updateDisplay();
      }
    });
  }

  // Initialize on page load and after view transitions
  initPaginatedList();
  document.addEventListener("astro:after-swap", initPaginatedList);
</script>
